module Lib
    ( someFunc
    , parseFile
    , parser
    , Status (..)
    ) where

import Data.List
import System.Exit
import Text.Parsec
import Text.Parsec.Char
import Text.Parsec.String


type Package = String
type Release = String
type Version = String
type Notes = String

data Status =
  -- Affected version does not exist in the archive
    DNE

  -- Still undecided
  | NEEDSTRIAGE

  -- Not vulnerable
  | NOTAFFECTED

  -- Package is vulnerable
  | NEEDED
  | ACTIVE
  | IGNORED -- Very low priority
  | PENDING
  | DEFERRED

  -- Fixed
  | RELEASED
  | RELEASEDESM
  deriving (Show)

type ReleasePackageStatus = (Release, Package, Status, Maybe Notes)

--
-- PARSER
--

key :: Parser String
key = (many1 (alphaNum <|> oneOf ".-_/")) <?> "key"

line = many1 (satisfy notNewline)
  where
    notNewline c = c /= '\n'

linevalue :: Parser String
linevalue = (try $ char ' ') *> line <?> "linevalue"

blockvalue :: Parser String
blockvalue = blockvalue' <?> "blockvalue"
  where
    blockvalue' = do string "\n "
                     lines <- line `sepBy1` try (string "\n ")
                     return $ intercalate "\n" lines

keyvalue :: Parser (String, String)
keyvalue = keyvalue' <?> "key-value"
  where
    keyvalue' = do k <- key
                   char ':'
                   v <- option "" $ try (blockvalue <|> linevalue)
                   return (k, v)

paragraph :: Parser [(String, String)]
paragraph = (keyvalue `sepEndBy1` (char '\n')) <?> "paragraph"

paragraphs = paragraph `sepEndBy1` (string "\n\n") 

--

release = (many1 (alphaNum <|> oneOf "-/")) <?> "release"
package = key <?> "package"

status :: Parser Status
status = (try $ string "DNE"          *> pure DNE)
     <|> (try $ string "ignored"      *> pure IGNORED)
     <|> (try $ string "not-affected" *> pure NOTAFFECTED)
     <|> (try $ string "needs-triage" *> pure NEEDSTRIAGE)
     <|> (try $ string "needed"       *> pure NEEDED)
     <|> (try $ string "active"       *> pure ACTIVE)
     <|> (try $ string "deferred"     *> pure DEFERRED)
     <|> (try $ string "pending"      *> pure PENDING)
     <|> (try $ string "released"     *> pure RELEASED)
     <|> (try $ string "released-esm" *> pure RELEASEDESM)

comment = comment' <?> "comment"
  where
    comment' = between (char '(') (char ')') (many (satisfy (/= ')')))
           <|> between (char '[') (char ']') (many (satisfy (/= ')')))

-- comment = do char '(' 
--              c <- many (alphaNum <|> space)
--              char ')'
--              return $ Just c

releasepackagestatus :: Parser ReleasePackageStatus
releasepackagestatus = do r <- release
                          char '_'
                          p <- package
                          string ": "
                          s <- status
                          c <- optionMaybe $ try (char ' ' *> comment)
                          return (r, p, s, c)

packageblock :: Parser [ReleasePackageStatus]
packageblock = do string "Patches_"
                  keyvalue
                  char '\n'
                  releasepackagestatus `sepEndBy1` (char '\n')

statusblock :: Parser [ReleasePackageStatus]
statusblock = do packages <- packageblock `sepEndBy1` (char '\n')
                 return $ concat packages


parser = do header <- paragraph
            many1 $ char '\n'
            status <- statusblock
            return (header, status)

--
parseFile :: Parser a -> String -> IO a
parseFile p fileName = parseFromFile p fileName >>= either report return
  where
    report err = do
        putStrLn $ "Error: " ++ show err
        exitFailure

someFunc :: IO ()
someFunc = putStrLn "Hello World!"
