module Lib
    ( someFunc
    , parser
    , parseFile
    , key
    , linevalue
    , keyvalue
    , value
    , blockvalue
    , paragraph
    , patchkey
    , release
    , package
    , status
    , comment
    , packageblock
    , releasepackagestatus
    , statusblock
    , cveParser
    , Status (..)
    ) where

import           Data.List
import           System.Exit
import           Text.Parsec
import           Text.Parsec.String


type Package = String
type Release = String
type Notes = String

data Status =
  -- Affected version does not exist in the archive
    DNE

  -- Still undecided
  | NEEDSTRIAGE

  -- Not vulnerable
  | NOTAFFECTED

  -- Package is vulnerable
  | NEEDED
  | ACTIVE
  | IGNORED -- Very low priority
  | PENDING
  | DEFERRED

  -- Fixed
  | RELEASED
  | RELEASEDESM
  deriving (Show, Eq)

type ReleasePackageStatus = (Release, Package, Status, Maybe Notes)

--
-- PARSER
--

whitespace :: Parser Char
whitespace = char ' '

whitespaces :: Parser String
whitespaces = many whitespace

key :: Parser String
key = many1 (noneOf "\n:") <?> "key"

linevalue:: Parser String
linevalue = (many1 (noneOf "\n")) <?> "value data"

blockvalue = do string "\n " <?> "mandatory newline and space at the begining of block"
                ls <- linevalue `sepBy1` (try $ string "\n ")
                return $ intercalate "\n" ls

value = value' <?> "value"
  where
    value' = option "" (try blockvalue <|> try linevalue)


keyvalue :: Parser (String, String)
keyvalue = keyvalue' <?> "key-value"
  where
    keyvalue' = do k <- key
                   char ':'
                   whitespaces
                   v <- value
                   return (k, v)

paragraph :: Parser [(String, String)]
paragraph = (keyvalue `sepEndBy` newline) <?> "paragraph"

--

release = (many1 $ noneOf "\n _") <?> "release"
package = (many1 $ noneOf ":") <?> "package"

status :: Parser Status
status = (try $ string "DNE"          *> pure DNE)
     <|> (try $ string "ignored"      *> pure IGNORED)
     <|> (try $ string "not-affected" *> pure NOTAFFECTED)
     <|> (try $ string "needs-triage" *> pure NEEDSTRIAGE)
     <|> (try $ string "needed"       *> pure NEEDED)
     <|> (try $ string "active"       *> pure ACTIVE)
     <|> (try $ string "deferred"     *> pure DEFERRED)
     <|> (try $ string "pending"      *> pure PENDING)
     <|> (try $ string "released-esm" *> pure RELEASEDESM)
     <|> (try $ string "released"     *> pure RELEASED)

comment = comment' <?> "comment"
  where
    comment' = between (char '(') (char ')') (try . many $ noneOf ")")
           <|> between (char '[') (char ']') (try . many $ noneOf "]")

releasepackagestatus :: Parser ReleasePackageStatus
releasepackagestatus = do r <- release
                          char '_'
                          p <- package
                          char ':'
                          whitespaces
                          s <- status
                          whitespaces
                          c <- optionMaybe comment
                          return (r, p, s, c)

patchkey :: Parser ()
patchkey = do string "Patches_"
              keyvalue <?> "keyvaluepatches"
              return ()

packageblock :: Parser [ReleasePackageStatus]
packageblock = do patchkey <?> "a key-value starting with 'Patches_'"
                  newline 
                  releasepackagestatus `sepEndBy` newline

statusblock :: Parser [ReleasePackageStatus]
statusblock = do packages <- packageblock `sepEndBy` (many1 newline)
                 return $ concat packages


cveParser = do header <- paragraph
               status <- option [] (skipMany1 newline *> statusblock)
               eof
               return (header, status)

parser = cveParser
--
parseFile :: Parser a -> String -> IO a
parseFile p fileName = parseFromFile p fileName >>= either report return
  where
    report err = do
        putStrLn $ "Error: " ++ show err
        exitFailure

someFunc :: IO ()
someFunc = putStrLn "Hello World!"
